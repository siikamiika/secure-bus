#!/usr/bin/env python3

import os
import sys
import time
import binascii
import struct
import socket
import queue
import select
import threading
import argparse

from cryptography.hazmat.primitives.ciphers.aead import ChaCha20Poly1305

class CryptoException(Exception):
    pass

class PskCipher:
    def __init__(
        self,
        psk,
        pad_chunk_size=1372, # 1400 - overhead for optimal TCP delivery
        clk_max_offset_sec=60.0
    ):
        self._last_clk_by_id = {}
        self._id = os.urandom(16)
        self._monotonic_offset = time.time() - time.monotonic()
        self._pad_chunk_size = pad_chunk_size
        self._clk_max_offset_sec = clk_max_offset_sec
        self._cipher = ChaCha20Poly1305(psk)

    def encrypt(self, data):
        pos = 0
        while pos < len(data):
            # print(pos, file=sys.stderr)
            nonce = os.urandom(12)
            clk = self._monotonic_offset + time.monotonic()
            clk_double = struct.pack('>d', clk)
            # ignore self
            self._last_clk_by_id[self._id] = clk
            # TODO what is the last 1
            next_pos = pos + self._pad_chunk_size - 16 - 8 - 1 - 1
            data_chunk = self._id + clk_double + data[pos:next_pos]
            pos = next_pos
            yield nonce + self._cipher.encrypt(nonce, self._pad(data_chunk), None)

    def decrypt(self, data):
        nonce, ciphertext = data[:12], data[12:]
        data = self._unpad(self._cipher.decrypt(nonce, ciphertext, None))
        src_id = data[0:16]
        clk = struct.unpack('>d', data[16:24])[0]
        plain = data[24:]
        if src_id in self._last_clk_by_id:
            # as a side effect, this will also prevent routing loop through multiple nodes
            if self._last_clk_by_id[src_id] >= clk:
                raise CryptoException('Replay or wrong payload order detected, aborting')
            if abs(time.time() - clk) > self._clk_max_offset_sec:
                raise CryptoException('Payload expired or clocks not in sync, aborting')
        self._last_clk_by_id[src_id] = clk
        return src_id, plain

    def _pad(self, data):
        assert len(data) <= self._pad_chunk_size - 1
        return (b'\x01' + data).rjust(self._pad_chunk_size, b'\x00')

    def _unpad(self, data):
        for i, b in enumerate(data):
            if b == 1:
                return data[i + 1:]
        return b''

def parse_addr(addr):
    host, port = addr.split(':')
    return host, int(port)

def recv_encrypted(read, write, cipher, identifier):
    while True:
        chunk = read(1400)
        if not chunk:
            break
        try:
            src_id, data = cipher.decrypt(chunk)
        except CryptoException as e:
            continue
        write((
            src_id,
            identifier,
            data,
            chunk,
        ))

# def recv_encrypted(read, write, cipher, identifier):
#     # TODO is this a thread safe implementation
#     ctx_by_src_id = {}
#     while True:
#         chunk = read(1400)
#         if not chunk:
#             break
#         try:
#             src_id, data = cipher.decrypt(chunk)
#         except CryptoException as e:
#             continue
#         if src_id not in ctx_by_src_id:
#             ctx_by_src_id[src_id] = {
#                 'raw_buf': [],
#                 'buf': [],
#                 'size': None,
#                 'pos': 0,
#             }
#         ctx = ctx_by_src_id[src_id]
#         ctx['raw_buf'].append(chunk)
#         if ctx['size'] is None:
#             ctx['size'] = struct.unpack('>L', data[:4])[0]
#             data = data[4:]
#         ctx['buf'].append(data)
#         ctx['pos'] += len(data)
#         if ctx['pos'] >= ctx['size']:
#             write((
#                 src_id,
#                 identifier,
#                 b''.join(ctx['buf']),
#                 b''.join(ctx['raw_buf']),
#             ))
#             del ctx_by_src_id[src_id]

class LocalServer:
    def __init__(self, addr, handle_communication):
        self._host, self._port = parse_addr(addr)
        self._handle_communication = handle_communication
        self._conns = []
        self._message_queue = queue.Queue()
        self._sock = self._create_server()
        threading.Thread(target=self._handle_connections).start()

    def send(self, data, identifier=None):
        # TODO timeout
        # TODO concurrent sending (is such a thing even possible?)
        for conn, addr in list(self._conns):
            if addr != identifier:
                try:
                    conn.send(data)
                except BrokenPipeError:
                    self._conns.remove((conn, addr))

    def listen(self):
        while True:
            yield self._message_queue.get()

    def _create_server(self):
        server_sock = socket.create_server((self._host, self._port))
        return server_sock

    def _handle_connections(self):
        while True:
            conn, addr = self._sock.accept()
            # print(conn, addr, file=sys.stderr)
            self._conns.append((conn, addr))
            threading.Thread(target=lambda: self._handle_communication(conn.recv, self._message_queue.put, addr)).start()

class RemoteServer:
    def __init__(self, addr, handle_communication):
        self._host, self._port = parse_addr(addr)
        self._handle_communication = handle_communication
        self._message_queue = queue.Queue()
        self._sock = self._create_client()
        self._handle_connection()

    def send(self, data, identifier=None):
        # TODO clean up self._conns on error
        # TODO timeout
        # TODO concurrent sending (is such a thing even possible?)
        if self._sock.getpeername() != identifier:
            try:
                self._sock.send(data)
            except BrokenPipeError:
                # TODO reconnect
                pass

    def listen(self):
        while True:
            yield self._message_queue.get()

    def _create_client(self):
        # TODO reconnect
        client_sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        client_sock.connect((self._host, self._port))
        return client_sock

    def _handle_connection(self):
        thread = threading.Thread(target=lambda: self._handle_communication(
            self._sock.recv,
            self._message_queue.put,
            self._sock.getpeername()
        ))
        thread.daemon = True
        thread.start()

def test_crypto(cipher):
    for p in [
        b'foo',
        b'foob',
        b'fooba',
        b'foobar',
    ]:
        c = cipher.encrypt(p * 3)
        src_id, p2 = cipher.decrypt(c)
        print(len(c), p2)

def main():
    parser = argparse.ArgumentParser(description='Secure Bus')
    parser.add_argument('--server-addr', nargs='?', help='Server listening address in the form host:port')
    parser.add_argument('--remote-server-addr', nargs='*', help='Remote server address in the form host:port')
    parser.add_argument('--wait-input', default=True, action=argparse.BooleanOptionalAction)
    args = parser.parse_args()

    with open(os.path.expanduser('~/.secure_bus_psk'), 'rb') as f:
        psk = binascii.unhexlify(f.read())
    cipher = PskCipher(psk)

    def handle_communication(read, write, identifier):
        recv_encrypted(read, write, cipher, identifier)

    servers = []
    if args.server_addr:
        local_server = LocalServer(args.server_addr, handle_communication)
        servers.append(local_server)
    for remote_addr in args.remote_server_addr or []:
        remote_server = RemoteServer(remote_addr, handle_communication)
        servers.append(remote_server)

    if args.wait_input:
        def listen_and_route(server):
            for src_id, identifier, data, encrypted_data in server.listen():
                # print(server, src_id, file=sys.stderr)
                sys.stdout.buffer.write(data)
                sys.stdout.buffer.flush()
                for server2 in servers:
                    server2.send(encrypted_data, identifier)
        for server in servers:
            threading.Thread(target=lambda: listen_and_route(server)).start()

    # TODO use (T)LV
    # for line in fileinput.input([]):
    #     data = line.encode('utf-8')
    #     size_ulong = struct.pack('>L', len(data))
    #     for data_encrypted in cipher.encrypt(size_ulong + data):
    #         local_server.send(data_encrypted)
    #         for remote_server in remote_servers:
    #             remote_server.send(data_encrypted)

    while True:
        rfnos, _, _ = select.select([0], [], [])
        data_sent = False
        for fno in rfnos:
            # TODO remove hard coded size
            data = os.read(fno, 1346)
            if data:
                for data_encrypted in cipher.encrypt(data):
                    # TODO wtf this breaks if the prints are not here
                    print('-' * 50, sys.stderr)
                    print(data_encrypted, file=sys.stderr)
                    for server in servers:
                        server.send(data_encrypted)
                data_sent = True
        if not data_sent:
            if not args.wait_input:
                break
            time.sleep(0.1)

if __name__ == '__main__':
    main()
