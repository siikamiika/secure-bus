#!/usr/bin/env python3

import os
import ctypes
import sys
import time
import binascii
import struct
import socket
import queue
import threading
import argparse

from cryptography.hazmat.primitives.ciphers.aead import ChaCha20Poly1305

class CryptoException(Exception):
    pass

class PskCipher:
    def __init__(
        self,
        psk,
        pad_chunk_size=1372, # 1400 - overhead for optimal TCP delivery
        clk_max_offset_ns=10_000_000_000, # 10 seconds
    ):
        self._id = os.urandom(12)
        self._ctx_by_id = {
            self._id: {
                'clk': None,
                'ctr': 0,
            }
        }
        self._pad_chunk_size = pad_chunk_size
        self._clk_max_offset_ns = clk_max_offset_ns
        self._cipher = ChaCha20Poly1305(psk)

    def encrypt(self, data):
        pos = 0
        # as a side effect, don't allow decrypting data encrypted with encrypt()
        ctx = self._ctx_by_id[self._id]
        while pos < len(data):
            # print(pos, file=sys.stderr)
            nonce = os.urandom(12)
            clk = time.time_ns()
            # don't reuse the same time, required for replay protection
            if ctx['clk'] is not None:
                clk = max(ctx['clk'] + 1, clk)
            ctx['clk'] = clk
            clk_ulonglong = struct.pack('>Q', clk)
            # TODO what is the last 1
            next_pos = pos + self._pad_chunk_size - 16 - 8 - 1 - 1
            data_chunk = self._id + struct.pack('>I', ctx['ctr']) + clk_ulonglong + data[pos:next_pos]
            ctx['ctr'] = (ctx['ctr'] + 1) % (2 ** 32)
            pos = next_pos
            yield nonce + self._cipher.encrypt(nonce, self._pad(data_chunk), None)

    def decrypt(self, data):
        nonce, ciphertext = data[:12], data[12:]
        data = self._unpad(self._cipher.decrypt(nonce, ciphertext, None))
        src_id = data[0:12]
        ctr = struct.unpack('>I', data[12:16])[0]
        clk = struct.unpack('>Q', data[16:24])[0]
        plain = data[24:]
        if src_id in self._ctx_by_id:
            ctx = self._ctx_by_id[src_id]
            # as a side effect, this will also prevent routing loop through multiple nodes
            if ctx['clk'] >= clk:
                raise CryptoException('Replay or wrong payload order detected, aborting')
            if abs(time.time_ns() - clk) > self._clk_max_offset_ns:
                raise CryptoException('Payload expired or clocks not in sync, aborting')
            if ctr != (ctx['ctr'] + 1) % (2 ** 32):
                print(ctr, ctx['ctr'], data[:16], file=sys.stderr)
                raise CryptoException('Counter was not incremented by 1, aborting')
            ctx['ctr'] = ctr
            ctx['clk'] = clk
        else:
            if ctr != 0:
                raise CryptoException('Counter did not start from 0, aborting')
            ctx = {
                'clk': clk,
                'ctr': ctr,
            }
            self._ctx_by_id[src_id] = ctx
        return src_id, plain

    def _pad(self, data):
        assert len(data) <= self._pad_chunk_size - 1
        return (b'\x01' + data).rjust(self._pad_chunk_size, b'\x00')

    def _unpad(self, data):
        for i, b in enumerate(data):
            if b == 1:
                return data[i + 1:]
        return b''

def parse_addr(addr):
    host, port = addr.split(':')
    return host, int(port)

def recv_encrypted(read, write, cipher, identifier):
    while True:
        chunk = read(1400)
        if not chunk:
            break
        while len(chunk) < 1400:
            chunk += read(1400 - len(chunk))
        try:
            src_id, data = cipher.decrypt(chunk)
        except CryptoException as e:
            continue
        write((
            src_id,
            identifier,
            data,
            chunk,
        ))

class LocalServer:
    def __init__(self, addr, handle_communication):
        self._host, self._port = parse_addr(addr)
        self._handle_communication = handle_communication
        self._conns = []
        self._message_queue = queue.Queue()
        self._sock = self._create_server()
        threading.Thread(target=self._handle_connections).start()

    def send(self, data, identifier=None):
        # TODO timeout
        # TODO concurrent sending (is such a thing even possible?)
        for conn, addr in list(self._conns):
            if addr != identifier:
                try:
                    conn.send(data)
                except (BrokenPipeError, ConnectionAbortedError):
                    self._conns.remove((conn, addr))

    def listen(self):
        while True:
            yield self._message_queue.get()

    def _create_server(self):
        server_sock = socket.create_server((self._host, self._port))
        return server_sock

    def _handle_connections(self):
        while True:
            conn, addr = self._sock.accept()
            # print(conn, addr, file=sys.stderr)
            self._conns.append((conn, addr))
            threading.Thread(target=lambda: self._handle_communication(conn.recv, self._message_queue.put, addr)).start()

class RemoteServer:
    def __init__(self, addr, handle_communication):
        self._host, self._port = parse_addr(addr)
        self._handle_communication = handle_communication
        self._message_queue = queue.Queue()
        self._sock = self._create_client()
        self._handle_connection()

    def send(self, data, identifier=None):
        # TODO clean up self._conns on error
        # TODO timeout
        # TODO concurrent sending (is such a thing even possible?)
        try:
            if self._sock.getpeername() != identifier:
                self._sock.send(data)
        except (BrokenPipeError, ConnectionAbortedError, OSError):
            # TODO reconnect
            pass

    def listen(self):
        while True:
            yield self._message_queue.get()

    def _create_client(self):
        # TODO reconnect
        client_sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        client_sock.connect((self._host, self._port))
        return client_sock

    def _handle_connection(self):
        thread = threading.Thread(target=lambda: self._handle_communication(
            self._sock.recv,
            self._message_queue.put,
            self._sock.getpeername()
        ))
        thread.daemon = True
        thread.start()

def test_crypto(cipher):
    for p in [
        b'foo',
        b'foob',
        b'fooba',
        b'foobar',
    ]:
        c = cipher.encrypt(p * 3)
        src_id, p2 = cipher.decrypt(c)
        print(len(c), p2)

def main():
    parser = argparse.ArgumentParser(description='Secure Bus')
    parser.add_argument('--server-addr', nargs='?', help='Server listening address in the form host:port')
    parser.add_argument('--remote-server-addr', nargs='*', help='Remote server address in the form host:port')
    parser.add_argument('--wait-input', default=True, action=argparse.BooleanOptionalAction)
    args = parser.parse_args()

    with open(os.path.expanduser('~/.secure_bus_psk'), 'rb') as f:
        psk = binascii.unhexlify(f.read())
    cipher = PskCipher(psk)

    def handle_communication(read, write, identifier):
        def _read(length):
            try:
                return read(length)
            except ConnectionResetError:
                return b''
        recv_encrypted(_read, write, cipher, identifier)

    servers = []
    if args.server_addr:
        local_server = LocalServer(args.server_addr, handle_communication)
        servers.append(local_server)
    for remote_addr in args.remote_server_addr or []:
        remote_server = RemoteServer(remote_addr, handle_communication)
        servers.append(remote_server)

    if args.wait_input:
        def listen_and_route(server):
            for src_id, identifier, data, encrypted_data in server.listen():
                # print(server, src_id, file=sys.stderr)
                sys.stdout.buffer.write(data)
                sys.stdout.buffer.flush()
                for server2 in servers:
                    server2.send(encrypted_data, identifier)
        for server in servers:
            threading.Thread(target=lambda: listen_and_route(server)).start()

    while True:
        # TODO remove hard coded size
        data = os.read(0, 1346)
        if data:
            for data_encrypted in cipher.encrypt(data):
                # print('-' * 50, file=sys.stderr)
                # print(data_encrypted, file=sys.stderr)
                for server in servers:
                    server.send(data_encrypted)
        else:
            break

if __name__ == '__main__':
    main()
