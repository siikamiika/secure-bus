#!/usr/bin/env python3

import os
import sys
import time
import binascii
import struct
import socket
import queue
import fileinput
import threading
import argparse

from cryptography.hazmat.primitives.ciphers.aead import ChaCha20Poly1305

class CryptoException(Exception):
    pass

class PskCipher:
    def __init__(
        self,
        psk,
        pad_chunk_size=1372, # 1400 - overhead for optimal TCP delivery
        clk_max_offset_sec=60.0
    ):
        self._last_clk_by_id = {}
        self._id = os.urandom(16)
        self._monotonic_offset = time.time() - time.monotonic()
        self._pad_chunk_size = pad_chunk_size
        self._clk_max_offset_sec = clk_max_offset_sec
        self._cipher = ChaCha20Poly1305(psk)

    def encrypt(self, data):
        nonce = os.urandom(12)
        clk = struct.pack('>d', self._monotonic_offset + time.monotonic())
        data = self._id + clk + data
        return nonce + self._cipher.encrypt(nonce, self._pad(data), None)

    def decrypt(self, data):
        nonce, ciphertext = data[:12], data[12:]
        data = self._unpad(self._cipher.decrypt(nonce, ciphertext, None))
        src_id = data[0:16]
        clk = struct.unpack('>d', data[16:24])[0]
        plain = data[24:]
        if src_id in self._last_clk_by_id:
            # as a side effect, this will also prevent routing loop through multiple nodes
            if self._last_clk_by_id[src_id] >= clk:
                raise CryptoException('Replay or wrong payload order detected, aborting')
            if abs(time.time() - clk) > self._clk_max_offset_sec:
                raise CryptoException('Payload expired or clocks not in sync, aborting')
        self._last_clk_by_id[src_id] = clk
        return src_id, plain

    def _pad(self, data):
        padded_length = (((len(data) + 1) // self._pad_chunk_size) + 1) * self._pad_chunk_size
        return (b'\x01' + data).rjust(padded_length, b'\x00')

    def _unpad(self, data):
        for i, b in enumerate(data):
            if b == 1:
                return data[i + 1:]
        return b''

def parse_addr(addr):
    host, port = addr.split(':')
    return host, int(port)

def recv_encrypted(read, write, cipher):
    # TODO is this a thread safe implementation
    ctx_by_src_id = {}
    while True:
        chunk = read(1400)
        if not chunk:
            break
        try:
            src_id, data = cipher.decrypt(chunk)
        except CryptoException as e:
            continue
        if src_id not in ctx_by_src_id:
            ctx_by_src_id[src_id] = {
                'raw_buf': [],
                'buf': [],
                'size': None,
                'pos': 0,
            }
        ctx = ctx_by_src_id[src_id]
        ctx['raw_buf'].append(chunk)
        if ctx['size'] is None:
            ctx['size'] = struct.unpack('>L', data[:4])[0]
            data = data[4:]
        ctx['buf'].append(data)
        ctx['pos'] += len(data)
        if ctx['pos'] >= ctx['size']:
            write((
                src_id,
                b''.join(ctx['buf']),
                b''.join(ctx['raw_buf']),
            ))
            del ctx_by_src_id[src_id]

class LocalServer:
    def __init__(self, addr, handle_communication):
        self._host, self._port = parse_addr(addr)
        self._handle_communication = handle_communication
        self._conns = []
        self._message_queue = queue.Queue()
        self._sock = self._create_server()
        threading.Thread(target=self._handle_connections).start()

    def send(self, data):
        # TODO clean up self._conns on error
        # TODO timeout
        # TODO concurrent sending (is such a thing even possible?)
        for conn, addr in self._conns:
            conn.send(data)

    def listen(self):
        while True:
            yield self._message_queue.get()

    def _create_server(self):
        server_sock = socket.create_server((self._host, self._port))
        return server_sock

    def _handle_connections(self):
        while True:
            # TODO use addr to filter flooded nodes (don't echo to sender)
            conn, addr = self._sock.accept()
            print(conn, addr)
            self._conns.append((conn, addr))
            threading.Thread(target=lambda: self._handle_communication(conn.recv, self._message_queue.put)).start()

class RemoteServer:
    def __init__(self, addr, handle_communication):
        self._host, self._port = parse_addr(addr)
        self._handle_communication = handle_communication
        self._message_queue = queue.Queue()
        self._sock = self._create_client()
        threading.Thread(target=self._handle_connection).start()

    def send(self, data):
        # TODO clean up self._conns on error
        # TODO timeout
        # TODO concurrent sending (is such a thing even possible?)
        self._sock.send(data)

    def listen(self):
        while True:
            yield self._message_queue.get()

    def _create_client(self):
        # TODO reconnect
        client_sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        client_sock.connect((self._host, self._port))
        return client_sock

    def _handle_connection(self):
        self._handle_communication(self._sock.recv, self._message_queue.put)

def test_crypto(cipher):
    for p in [
        b'foo',
        b'foob',
        b'fooba',
        b'foobar',
    ]:
        c = cipher.encrypt(p * 3)
        src_id, p2 = cipher.decrypt(c)
        print(len(c), p2)

def main():
    parser = argparse.ArgumentParser(description='Secure Bus')
    parser.add_argument('--server-addr', nargs='?', default=':58823', help='Server listening address in the form host:port. Default 58823')
    parser.add_argument('--remote-server-addr', nargs='*', help='Remote server address in the form host:port')
    args = parser.parse_args()

    with open(os.path.expanduser('~/.secure_bus_psk'), 'rb') as f:
        psk = binascii.unhexlify(f.read())
    cipher = PskCipher(psk)

    def handle_communication(read, write):
        recv_encrypted(read, write, cipher)

    local_server = LocalServer(args.server_addr, handle_communication)
    remote_servers = [RemoteServer(a, handle_communication) for a in args.remote_server_addr or []]

    def listen_and_route(server):
        for src_id, data, encrypted_data in server.listen():
            print(server, src_id, data)
            for server2 in [local_server] + remote_servers:
                server2.send(encrypted_data)
    threading.Thread(target=lambda: listen_and_route(local_server)).start()
    for remote_server in remote_servers:
        threading.Thread(target=lambda: listen_and_route(remote_server)).start()

    # TODO use (T)LV
    for line in fileinput.input([]):
        data = line.encode('utf-8')
        size_ulong = struct.pack('>L', len(data))
        data_encrypted = cipher.encrypt(size_ulong + data)
        local_server.send(data_encrypted)
        for remote_server in remote_servers:
            remote_server.send(data_encrypted)

if __name__ == '__main__':
    main()
